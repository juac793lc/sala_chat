import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import '../models/contenido_multimedia.dart';
import '../services/upload_service.dart';
import '../services/auth_service.dart';
import '../config/endpoints.dart';

class InputMultimediaWidget extends StatefulWidget {
  final Function(ContenidoMultimedia) onContenidoAgregado;
  final VoidCallback? onMapaTap;
  final String roomId;

  const InputMultimediaWidget({
    super.key,
    required this.onContenidoAgregado,
    required this.roomId,
    this.onMapaTap,
  });

  @override
  State<InputMultimediaWidget> createState() => _InputMultimediaWidgetState();
}

class _InputMultimediaWidgetState extends State<InputMultimediaWidget>
    with TickerProviderStateMixin {
  late final AnimationController _animationController;
  late final Animation<double> _scaleAnimation;
  // No almacenar PIN en c\u00f3digo; pediremos al usuario que lo introduzca al intentar subir

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 140),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1, end: 0.92).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
  }

  Future<void> _requestAdminPinThenOpenGallery() async {
    final controller = TextEditingController();
    final result = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Clave administrativa'),
        content: TextField(
          controller: controller,
          obscureText: true,
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            hintText: 'Introduce la clave',
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancelar')),
          ElevatedButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            child: const Text('Aceptar'),
          ),
        ],
      ),
    );

    if (result != true) return;
    final pin = controller.text.trim();
    if (pin == '041990') {
      await _abrirGaleriaDirecta();
    } else {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Clave incorrecta'), backgroundColor: Colors.red),
      );
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  Future<void> _abrirGaleriaDirecta() async {
    try {
      // Mostrar indicador de carga
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Seleccionando archivo...'),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 1),
          behavior: SnackBarBehavior.floating,
        ),
      );

      final picker = ImagePicker();
      final XFile? archivo = await picker.pickMedia();
      if (archivo == null) return;

      // Mostrar indicador de subida
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Subiendo archivo...'),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 10),
          behavior: SnackBarBehavior.floating,
        ),
      );

      final nombre = archivo.name.toLowerCase();
      final esVideo = nombre.endsWith('.mp4') ||
          nombre.endsWith('.mov') ||
          nombre.endsWith('.avi') ||
          nombre.endsWith('.mkv') ||
          nombre.endsWith('.webm');

      // Obtener datos del usuario
      final user = AuthService.getCachedUser();
      final userId = user?.id ?? '1';
      final userNombre = user?.username ?? 'Usuario';

      // Subir archivo al backend (manejar diferencias entre web y m\u00f3vil)
      late UploadResult uploadResult;
      
      if (kIsWeb) {
        // En web, necesitamos usar los bytes directamente
        final bytes = await archivo.readAsBytes();
        final fileName = archivo.name;
        
        // Para web, usamos una estrategia diferente - enviamos los bytes directamente
        uploadResult = await _uploadBytesWeb(
          bytes,
          fileName,
          esVideo ? 'video' : 'image',
          widget.roomId,
          userId,
          userNombre,
        );
      } else {
        // En m\u00f3vil, usamos el path normalmente
        uploadResult = await UploadService.uploadFile(
          archivo.path,
          esVideo ? 'video' : 'image',
          roomId: widget.roomId,
          userId: userId,
          userNombre: userNombre,
        );
      }

      // Crear contenido multimedia con datos del servidor
      final contenido = ContenidoMultimedia(
        id: uploadResult.mediaId ?? uploadResult.fileId,
        autorId: userId,
        autorNombre: userNombre,
        tipo: esVideo ? TipoContenido.video : TipoContenido.imagen,
        url: uploadResult.url,
        fechaCreacion: uploadResult.uploadedAt,
        duracionSegundos: 0,
      );

      // Notificar a la pantalla principal (que se encargar\u00e1 de la emisi\u00f3n por socket)
      widget.onContenidoAgregado(contenido);

      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(esVideo
              ? 'Video subido correctamente'
              : 'Imagen subida correctamente'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).hideCurrentSnackBar();
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error al subir archivo: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 3),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
        ),
      );
    }
  }

